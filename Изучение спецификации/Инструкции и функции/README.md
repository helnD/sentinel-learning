# Инструкции в языке Sentinel

## Условия

В языке sentinel существует два инструкции, которые отвечают за ветвления: if/else и case/when/else

Привычная инструкция if/else работает так же, как и в других языках и синтаксически выглядит следующим образом:

```
if x < y {
    // do something.
} else if x > z {
    // if x not more than y and more than z do that.
} else {
    // otherwise do that.
}
```

Внутри условия действует свое пространство имен. Если инструкция if/else многим знакома, то инструкция case/when нуждается в пояснениях. В полном своем варианте, она аналогична инструкции switch/case, т.е. позволяет выбрать один из путей исполнения на основе сравнения одного значения с другими:

```
case x {
when y, z:
    // do that
when r:
    // or do that
else:
    // otherwise do that
}
```

Здесь x сравнивается со значениеми y, z, r. Если x равен y или z, то выполнится первый блок. Если x равен r, то второй. Если x не равен y, z и r, то выполнится блок else Однако, у этой инструкции есть вторая форма, которая записывается без какого-либо значения после ключегого слова case.

```
case {
when x > 42:
    // do that
else:
    // otherwise do that
}
```

На самом деле, данная конструкция будет преобразована в другую, конструкцию, описанную ниже. Такое преобразование позволяет в компактном виде записать множество условий и исполнить только тот блок, что вам нужен.

```
case true {
when x > 42:
    // do that
else:
    // otherwise do that
}
```

## Циклы

В языке sentinel ксть только один цикл for и работает он только с перечислениями, как и люой современный язык. Цикл for имеет две формы. Одна позволяет перебрать список без индекса, другая же этот индекс предоставляет.

```
// Форма без индекса
for [1, 2, 3] as element {
    // do something for every element.
}

// Форма с индексом
for [1, 2, 3] as element, index {
    // do something for every element and index.
}
```
Сама работа цикла знакома каждому программисту, этот цикл выполняет определенные в его теле операции для каждого елемента из списка. Также в языке работают знакомые операторы безусловного перехода continue и break. Внутри цикла действует свое пространство имен.

# Функции и политики

Хоть политики и описываются так поздно, они являются основными структурными блоками при использовании языка sentinel. Описываю я их только сейчас, так как при их использовании лучше иметь представление о базовых выражениях и инструкциях. Функции также являются важным структурным  эелементом, позволяющим переиспользовать ранее написанный код в рамках одного файла.

## Функции

Как и везде, функция состоит из объявления и использования. Пример объявления выглядит так:

```
pow_2 = func(number) {
    return number * number
}
```

Имя функции будет pow_2, она принимает 1 аргумент number и возвращает квадрат этого числа. Особенность функций, объявленных с помощью языка, это их ограниченная область действия - только в пределах файла. Существует возможность написать импортируемые функции, эта тема обсуждается в главе 3. Также, функция имеет свое пространство имен. Если функция не возвращает значение явно, неявно будет подставлено значение undefined. Для использования функции, ее нужно присвоить переменной при объявлении. Переданные в функция аргументы передаются по значению (копируются)

## Политики

Как правило, политика является некоторым логическим выражением и нужна для того, чтобы проверить, удовлетворяет набор входных параметров некоторому условия (зачаствую очень сложному и комплексному) или нет. Важная особенность политик в том, что факт их выполнения или не выполнения отображается в выводе консоли в виде трассировки пройденных политик. Примеры объявления политик:
```
rule {
    x == "value" or y == "other"
}

rule {
    x + y
}

# y more than 42
rule when x is y { y > 42 }
```
В первом случая объявлена политика, которая будет пройдена только в том случае, если x = "value" или y = "other". И если здесь все просто, то вторая политика может ввести в заблуждение, так как она просто возвращает значение. На самом деле, политика может просто возвращать значения, но такое поведение не желательно и специфично только для случая, когда нам нужно включить факт возвращения значения в трассировку или вернуть значение, которое будет показывать, как и почему именно провалилась политика. Если политика возвращает значение, то любое значение кроме нуля будет означать провал политики.

Последняя политика помечена комментарием. Этот комментарий позволяет вывести описание политики в трассировку, что очень важно, когда сложность политик начинает возрастать. Другой особенностью последней политики является ключевое слово when, которое позволяет сделать защитное условие для исполнения политики. Если выражение после when ложно, то тело политики не будет выполнено и она будет считаться пройденной. Если условие после when не выполняется, то процесс обработки политики будет стандартным.

Важная особенность политик - их можно (и даже нужно) присваивать переменным. Так, мы обязаны присвоить переменной main нашу базовую политику, которая по своей сути будет точкой входа.  

## Параметры политик

Отдельного внимания заслуживают параметры политик. Это те значения, которые зачастую составляют входные данные политики. Параметры объявляются после секции с импортами и могут иметь практически любой тип (вычисленный на этапе выполнения). Параметрам нельзя присваивать функции и другие политики. Для объявления параметров нужно указать ключевое слово param с именем параметра:

```
param foo
param bar default 42
```

Здесь объявлено два параметра: foo и bar. Можно заметить, что второму параметру дано значение по умолчанию. Если параметру не дано такое значение, то он является обязательным. Как и к политикам, к параметрам можно дописывать комментари, которые будут их описанием при работе в консоли.

Передавать параметры можно большим количеством способов. Можно создавать переменные среды со специальным префиксом SENTINEL_PARAM_:
```
SENTINEL_PARAM_foo = 42
```
Параметры можно передавать с помощью опции -param команды apply в формате key=value:
```
sentinel apply -param foo=42 policy.sentinel
```
Параметры можно передавать в конфигурационном файле политики (<policy_name>.[hcl|json]):
```
{
  "param": {
    "foo": 42
  }
}
```
И наконец, параметры можно передать в интерактивном режиме. Если по каким-то причинам вы не указали обязательные параметры, вам предложат их ввести:
```
~/sentinel apply policy.sentinel

policy.sentinel:2:7: requires value for parameter foo
  An example parameter. Must be supplied or the policy will fail.

  Values can be strings, floats, or JSON array or object values. To force
  strings, use quotes.

  Enter a value: _
```
# Встроенные функции

Большинство встроенных функций уже обсуждались, когда я рассказывал про работу со структурами данных. Однако есть ряд функций, которые необходимо использовать, но они не упомянались ранее.

## Приведение типов

Важнейший класс функций, которые позволяют привести значение одного типа к другому. Все эти функции имеют один параметр. Их имя соответствует имени типа, к которому надо привести аргумент. Таких функций четыре: int, float, string и bool. Привожу правила, по которым одни типы приводятся к другим, из документации:
```
For int:
    Integer values are unchanged
    String values are converted according to the syntax of integer literals
    Float values are rounded down to their nearest integer value
    Boolean values are converted to 1 for true, and 0 for false

For float:
    Float values are unchanged
    Integer values are converted to the nearest equivalent floating point value
    String values are converted according to the syntax of float literals
    Boolean values are converted to 1.0 for true, and 0.0 for false

For string:
    String values are unchanged
    Integer values are converted to the base 10 string representation
    Float values are converted to a string formatted xxx.xxx with a precision of 6. This is equivalent to %f for C's sprintf.
    Boolean values are converted to "true" for true, and "false" for false

For bool:
    The following string values convert to true: "1", "t", "T", "TRUE", "true", and "True"
    The following string values convert to false: "0", "f", "F", "FALSE", "false", and "False"
    Any non-zero integer or float value converts to true
    Any zero integer or float value converts to false

For any other unspecified type, the result is the undefined value.
```

## Функции вывода

Функция print выводит на экран текстовое представление своего параметра. Если параметров несколько, они выводятся через пробел:

```
print("hello")                    // "hello"
print("hello", "world")           // "hello world"
print("The", "number", "is", 42)  // "The number is 42"
print([1, 2, 3])                  // "[1, 2, 3]"
```
Если функция print является результатом работы политики, то политика будет успешно пройдена.

Другой функцией вывода является error, однако кроме печати информации к конслоль, она тут же останавливает проверку политики. Сама политика будет считаться не пройденной.

## Range

Последней встроенной функцией, которая не обсуждалась раньше, является функция range. Как и во многих других языках, она создает массив последовательных чисел с возможностью задания шага:
```
range(5)           // [0,1,2,3,4]
range(1, 5)        // [1,2,3,4]
range(1, 5, 2)     // [1,3]
range(0, -3, -1)   // [0,-1,-2]
```